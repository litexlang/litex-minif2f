# vector

have fn:
    add(a cart(R, R), b cart(R, R)) cart(R, R):
        add(a, b) = (a[1] + b[1], a[2] + b[2])

    witness:
        have c cart(R, R) = (a[1] + b[1], a[2] + b[2])
    = c

have fn:
    sub(a cart(R, R), b cart(R, R)) cart(R, R):
        sub(a, b) = (a[1] - b[1], a[2] - b[2])

    witness:
        have c cart(R, R) = (a[1] - b[1], a[2] - b[2])
    = c

have fn:
    sm(a R, b cart(R, R)) cart(R, R):
        sm(a, b) = (a * b[1], a * b[2])

    witness:
        have c cart(R, R) = (a * b[1], a * b[2])
    = c

have fn:
    mod(a cart(R, R)) R:
        mod(a) = sqrt(a[1]^2 + a[2]^2)

    witness:
        a[1]^ 2 >= 0
        a[2]^ 2 >= 0
        a[1]^2 + a[2]^2 >= 0
        have c R = sqrt(a[1]^2 + a[2]^2)
    = c

have fn:
    prod(a cart(R, R), b cart(R, R)) R:
        prod(a, b) = a[1] * b[1] + a[2] * b[2]

    witness:
        have c R = a[1] * b[1] + a[2] * b[2]
    = c

# line as set
have s set = {x R: x > 0}
forall x R: x > 0 => x $in s
s $subset_of R

have s2 set = {x cart(R, R): x[1] > 0}
forall x cart(R, R): x[1] > 0 => x $in s2

have s3 set = {x cart(R, R): x[1] + x[2] = 0}
forall x cart(R, R): x[1] + x[2] = 0 => x $in s3

# = {} 的释放不是自动的，只能取个名字。本质原因是因为 = {} 是一个fact，{} 不是一个obj
prop line_as_intensional_set(s set, a, b, c R):
    s = {x cart(R, R): a * x[1] + b * x[2] = c}

have fn:
    line(a, b, c R) power_set(cart(R, R)):
        dom:
            a != 0 or b != 0
        =>:
            line(a, b, c) = {x cart(R, R): a * x[1] + b * x[2] = c}
            $line_as_intensional_set(line(a, b, c), a, b, c)
            $is_set(line(a, b, c))

    witness:
        have l set = {x cart(R, R): a * x[1] + b * x[2] = c}
        forall x l: x $in cart(R, R)
        l $subset_of cart(R, R)
    = l

# 举例：line(1, 1, 1) 是 line 的实例
prove:
    $line_as_intensional_set(line(1, 1, 1), 1, 1, 1)
    line(1, 1, 1) = {x cart(R, R): 1 * x[1] + 1 * x[2] = 1}
    forall x line(1, 1, 1):
        x $in cart(R, R)
        1 * x[1] + 1 * x[2] = 1

prove forall a, b, c R: a != 0 => line(a, b, c) = line(1, b/a, c/a):
    $line_as_intensional_set(line(a, b, c), a, b, c)
    $line_as_intensional_set(line(1, b/a, c/a), 1, b/a, c/a)

    forall x line(a, b, c):
        x $in cart(R, R)
        a * x[1] + b * x[2] = c
        (a * x[1] + b * x[2]) / a = c / a = x[1] + (b / a) * x[2]
        x $in line(1, b/a, c/a)

    forall x line(1, b/a, c/a):
        x $in cart(R, R)
        1 * x[1] + (b / a) * x[2] = c / a
        a * (1 * x[1] + (b / a) * x[2]) = a * x[1] + b * x[2] = a * (c / a) = c
        x $in line(a, b, c)

    $is_set(line(a, b, c))
    $is_set(line(1, b/a, c/a))

    line(a, b, c) $subset_of line(1, b/a, c/a)
    line(1, b/a, c/a) $subset_of line(a, b, c)

    line(a, b, c) = line(1, b/a, c/a)


# 是截距
prop is_intercept(i R, a, b, c R):
    (0, i) $in line(a, b, c)

# 1 是 line(1, 1, 1) 的截距
prove:
    $line_as_intensional_set(line(1, 1, 1), 1, 1, 1)
    $is_intercept(1, 1, 1, 1)

# 两点式
have fn:
    line_two_points(x cart(R, R), y cart(R, R)) power_set(cart(R, R)):
        dom:
            x[2] - y[2] != 0 or y[1] - x[1] != 0
        =>:
            line_two_points(x, y) = line(x[2] - y[2], y[1] - x[1], x[2] * y[1] - x[1] * y[2])

    witness:
        have l power_set(cart(R, R)) = line(x[2] - y[2], y[1] - x[1], x[2] * y[1] - x[1] * y[2])

    = l

# (1, 0), (0, 1) 在直线 line(1, 1, 1) 上；他们用两点式做出来的直线就是 line(1, 1, 1)
prove:
    $line_as_intensional_set(line(1, 1, 1), 1, 1, 1)
    (1, 0) $in line(1, 1, 1)
    (0, 1) $in line(1, 1, 1)

    line_two_points((1, 0), (0, 1)) = line((0-1), (0-1), (0 * 0 - 1 * 1)) = line(-1, -1, -1) = line(1, 1, 1)

# 点法式：给定法向量(a, b) 和点 (x0, y0)，则直线为 {x cart(R, R): a * (x[1] - x0) + b * (x[2] - y0) = 0}
have fn:
    line_normal_vector(x cart(R, R), y cart(R, R)) power_set(cart(R, R)):
        x[1] != 0 or x[2] != 0
        =>:
            line_normal_vector(x, y) = line(x[1], x[2], x[1] * y[1] + x[2] * y[2])

    witness:
        have l power_set(cart(R, R)) = line(x[1], x[2], x[1] * y[1] + x[2] * y[2])

    = l

# 两个直线垂直
prop is_vertical(s1 power_set(cart(R, R)), s2 power_set(cart(R, R)), a, b, c, d, e, f R):
    s1 = line(a, b, c)
    s2 = line(d, e, f)
    <=>:
        a * d + b * e = 0

# 点到直线的距离公式：点 pt 到直线 a * x + b * y = c 的距离
have fn:
    distance_point_to_line(pt cart(R, R), a, b, c R) R:
        dom:
            a^2 + b^2 > 0
        =>:
            distance_point_to_line(pt, a, b, c) = abs(a * pt[1] + b * pt[2] - c) / sqrt(a^2 + b^2)

    witness:
        a^2 + b^2 > 0
        have d R = sqrt(a^2 + b^2)
        sqrt(a^2 + b^2) > 0
        have numerator R = abs(a * pt[1] + b * pt[2] - c)
        have result R = numerator / d
    = result


# absolute
let fn absolute(x R) R
know:
    forall x R: x >= 0 => absolute(x) = x
    forall x R: x < 0 => absolute(x) = -x
    

# modular inverse
prop is_mod_inv(m, n Z, k N_pos):
    (m * n) % k = 1

have mod_inv fn(Z, N_pos) N
know:
    forall x, y Z, k N_pos:
        0 <= y
        y < k
        $is_mod_inv(x, y, k)
        <=>:
            mod_inv(x, k) = y

# properties of modular arithmetic
know forall m, n, k N_pos => n^k % m = ((n % m)^k) % m

# factorial
have factorial fn(N) N_pos
know:
    factorial(0) = 1
    factorial(1) = 1
    forall n N: factorial(n) = factorial(n - 1) * n

algo factorial(n):
    if n = 0:
        return 1
    if n = 1:
        return 1
    return factorial(n - 1) * n

eval factorial(10)
factorial(10) = 3628800


# sum
have sum fn(N) N_pos
know:
    sum(1) = 1
    forall n N: sum(n) = sum(n - 1) + n
algo sum(n):
    if n = 1:
        return 1
    return sum(n - 1) + n